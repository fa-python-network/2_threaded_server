<!----- Conversion time: 0.718 seconds.
Using this Markdown file:

1. Cut and paste this output into your source file.
2. See the notes and action items below regarding this conversion run.
3. Check the rendered output (headings, lists, code blocks, tables) for proper
   formatting and use a linkchecker before you publish this page.

Conversion notes:

* Docs to Markdown version 1.0β17
* Wed Sep 18 2019 01:52:00 GMT-0700 (PDT)
* Source doc: https://docs.google.com/open?id=1SEODmwLcgVdQijJMZ6Xc3YQ0lqnkc72w-gccG4AkpqU
----->

## Создание простого многопоточного сервера

### Цель работы

Познакомиться с приемами работы с многопоточностью на примере создания сокетного TCP-сервера, способного работать с несколькими клиентами одновременно

### Задания для выполнения

1. Создать простой эхо-сервер и клиент для него.
2. Модифицировать код сервера таким образом, чтобы при подключении нового клиента создавался новый поток и вся работа с клиентом выполнялась в нем.
3. Проверить возможность подключения нескольких клиентов к этому серверу одновременно. 

### Методические указания

Потоки управления (threads) образуются и работают в рамках одного процесса. В однопоточном приложении (программе, которая не использует дополнительных потоков) имеется только один поток управления. Говоря упрощенно, при запуске программы этот поток последовательно исполняет встречаемые в программе операторы, направляясь по одной из альтернативных ветвей оператора выбора, проходит через тело цикла нужное число раз, выбирается к месту обработки исключения при возбуждении исключения. В любой момент времени интерпретатор Python знает, какую команду исполнить следующей. После исполнения команды становится известно, какой команде передать управление. Эта ниточка непрерывна в ходе выполнения программы и обрывается только по ее завершении.

Теперь можно представить себе, что в некоторой точке программы ниточка раздваивается, и каждый поток идет своим путем. Каждый из образовавшихся потоков может в дальнейшем еще несколько раз раздваиваться. (При этом один из потоков всегда остается главным, и его завершение означает завершение всей программы.) В каждый момент времени интерпретатор знает, какую команду какой поток должен выполнить, и уделяет кванты времени каждому потоку. Такое, казалось бы, незначительное усложнение механизма выполнения программы на самом деле требует качественных изменений в программе - ведь деятельность потоков должна быть согласована. Нельзя допускать, чтобы потоки одновременно изменяли один и тот же объект, результат такого изменения, скорее всего, нарушит целостность объекта.

Давайте рассмотрим использование потоков на примере. Перед нами стоит задача запустить 10 000 ракет в космос. 
Ниже представлен код, имитирующий запуск.

```python
import time
import random


def random_delay():
    return random.random() * 5


def random_countdown():
    return random.randrange(5)


def launch_rocket(delay, countdown):
    time.sleep(delay)
    for i in reversed(range(countdown)):
        print(f"{i + 1}...")
        time.sleep(1)
    print("Rocket launched!")


def rockets():
    return [(random_delay(), random_countdown()) for _ in range(10_000)]


if __name__ == '__main__':
    for d, c in rockets():
        launch_rocket(d, c)
```

Запустив код, мы скорее всего не захотим дожидаться его завершения. Ведь каждая следующая ракета начинает готовиться к 
запуску лишь после запуска предыдущей. Запуск ракет происходит последовательно из-за того, что вся программа выполняется в одном потоке. 
Давайте исправим это.

В следующем примере для запуска каждой ракеты создается свой поток:

```python
from threading import Thread


def run_threads():
    threads = [
        Thread(target=launch_rocket, args=(delay, countdown))
        for delay, countdown in rockets()
    ]

    for t in threads:
        t.start()

    for t in threads:
        t.join()


if __name__ == '__main__':
    run_threads()
```

Сначала получается 10 000 объектов класса Thread, которые затем и запускаются с различными аргументами. 
В данном случае в потоках работает одна и та же функция `launch_rocket()`, которой передается кортеж из 
двух аргументов delay и countdown, заданный в именованном параметре args конструктора класса Thread. 
Нетрудно догадаться, что метод `start()` служит для запуска нового потока. 
Таким образом, в приведенном примере работает 10 001 поток: основной и 10 000 дополнительных, в каждом из которых происходит запуск ракеты.

Но в приведенном коде можно увидеть нечто странное: именованный аргумент, который называется `args` и передача функции 
в качестве параметра `target`. Можно было бы просто передать замыкание и не делать это классом, а сделать это функцией, 
которая принимает замыкание и список позиционных аргументов переменной длины `*args`. Это связанно с тем, что api класса скопирован с реализации потоков в Java.

Поэтому более **pythonic way** стиль заключается в создании собственного класса через наследование от `threading.Thread` с переопределением конструктора и метода `run()`:

```python
class Rocket(Thread):

    def __init__(self, delay, countdown, name=None):
        super(Rocket, self).__init__(name=name)
        self.delay = delay
        self.countdown = countdown

    def run(self):
        launch_rocket(self.delay, self.countdown)


def run_rockets():
    threads = [Rocket(delay, countdown) for delay, countdown in rockets()]

    for t in threads:
        t.start()

    for t in threads:
        t.join()


if __name__ == '__main__':
    run_rockets()
```

Данный пример отлично демонстрирует преимущества многопоточного кода над выполнением программы в одном потоке.

### Контрольные вопросы

1. Почему однопоточное приложение не может решить задачу одновременного подключения?
2. Чем поток отличается от процесса?
3. Как создать новый поток?
4. Как выделить участок кода так, чтобы он выполнялся в другом потоке?
5. В чем проблема потокобезопасности?
6. Какие методы обеспечения потокобезопасности существуют?

### Дополнительные задания

1. Реализовать сканер TCP-портов. Программа должна запрашивать имя хоста/IP-адрес у пользователя. Затем программа должна пробовать подключиться к этому хосту ко всем портами по очереди. При успешном подключении программа должна выводить в консоль сообщение “Порт N открыт”. 
    1. Модифицировать эту программу, чтобы сканирование портов происходило параллельно. Для этого нужно распараллелить сканирование портов по нескольким потокам. 
    2. Обеспечить вывод списка открытых портов по порядку.
    3. Реализовать progress bar в командной строке, показывающий прогресс сканирования.
2. Модифицировать простой эхо-сервер таким образом, чтобы при подключении клиента создавался новый поток, в котором происходило взаимодействие с ним.
2. Реализовать простой чат сервер на базе сервера аутентификации. Сервер должен обеспечивать подключение многих пользователей одновременно, отслеживание имен пользователей, поддерживать историю сообщений и пересылку сообщений от каждого пользователя всем остальным. 
3. Реализовать сервер с управляющим потоком. При создании сервера прослушивание портов происходит в отдельном потоке, а главный поток программы в это время способен принимать команды от пользователя. Необходимо реализовать следующие команды:
    1. Отключение сервера (завершение программы);
    2. Пауза (остановка прослушивание порта);
    3. Показ логов;
    4. Очистка логов;
    5. Очистка файла идентификации.

<!-- Docs to Markdown version 1.0β17 -->
